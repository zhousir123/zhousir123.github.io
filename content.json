{"meta":{"title":"Mr.zhou的blog","subtitle":null,"description":null,"author":"Mr.zhou","url":"https://zo.subo.xyz","root":"/"},"pages":[{"title":"","date":"2019-08-14T13:26:19.356Z","updated":"2019-08-10T17:01:46.711Z","comments":true,"path":"404.html","permalink":"https://zo.subo.xyz/404.html","excerpt":"","text":""},{"title":"","date":"2019-08-14T13:26:19.352Z","updated":"2019-08-10T15:26:49.589Z","comments":true,"path":"baidu_verify_XeWR9kzXZ9.html","permalink":"https://zo.subo.xyz/baidu_verify_XeWR9kzXZ9.html","excerpt":"","text":"XeWR9kzXZ9"},{"title":"","date":"2019-08-14T13:26:19.360Z","updated":"2019-08-11T10:55:33.477Z","comments":true,"path":"googlea28ffae42df3c06e.html","permalink":"https://zo.subo.xyz/googlea28ffae42df3c06e.html","excerpt":"","text":"google-site-verification: googlea28ffae42df3c06e.html"},{"title":"about","date":"2019-08-11T18:28:20.000Z","updated":"2019-08-14T08:25:52.354Z","comments":false,"path":"about/index.html","permalink":"https://zo.subo.xyz/about/index.html","excerpt":"","text":"hellothis is my blogIt’s the loser"},{"title":"categories","date":"2018-03-02T04:33:16.000Z","updated":"2019-08-12T03:46:38.785Z","comments":false,"path":"categories/index.html","permalink":"https://zo.subo.xyz/categories/index.html","excerpt":"","text":""},{"title":"有事请留言","date":"2019-08-12T07:52:05.000Z","updated":"2019-08-12T08:06:27.640Z","comments":true,"path":"message/index.html","permalink":"https://zo.subo.xyz/message/index.html","excerpt":"","text":"有事请留言"},{"title":"tags","date":"2019-08-11T18:28:19.000Z","updated":"2019-08-12T03:37:50.312Z","comments":false,"path":"tags/index.html","permalink":"https://zo.subo.xyz/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"mariadb的搭建及使用","slug":"centos 7 安装mariadb","date":"2019-08-15T02:33:42.000Z","updated":"2019-08-14T02:28:14.589Z","comments":true,"path":"2019/08/15/centos 7 安装mariadb/","link":"","permalink":"https://zo.subo.xyz/2019/08/15/centos 7 安装mariadb/","excerpt":"","text":"@TOC 序言听说Oracle 公司要对mysql 进行推出收费版本了,一般收费版本肯定要比免费使用的版本功能更强大些,所以我感觉说不定要对免费版本限制功能了,那这样的话,还不如开始使用MySQL原作者推出的免费版–mariadb其实就一点,跟centos一个样 免费跟收费的区别,所以一般公司用的还大多是centos ,为啥 不收费呀! ,而且centos就是rhel是一模一样的,唯一的差别改了一个图标而已,t同理,mysql跟mariadb底层是通用的,mariadb兼容MySQL,而且在MySQL的基础上增加了很多功能,更为强大好用 &nbsp; 由于官网的MariaDB版本要比阿里云的版本要高，所以我们应该优先使用官方的版本 注意: 在centos7 中默认使用的数据库已经切换成了mariadb,所以我们通过yum安装的时候,直接安装MySQL就行 首先 添加MariaDB yum仓库 1、首先在 RHEL/CentOS 和 Fedora 操作系统中添加 MariaDB 的 YUM 配置文件 MariaDB.repo 文件。12# 编辑创建mariadb.repo仓库文件vi /etc/yum.repos.d/MariaDB.repo 2、添加repo仓库配置12345[mariadb]name=MariaDBbaseurl=http://yum.mariadb.org/10.1/centos7-amd64gpgkey=https://yum.mariadb.org/RPM-GPG-KEY-MariaDBgpgcheck=1 3、当 MariaDB 仓库地址添加好后，你可以通过下面的一行命令轻松安装 MariaDB。1yum install MariaDB-server MariaDB-client -y 4、如果官方的版本下载太慢，我们就直接使用阿里云的比较低的版本也可以(1) 删除或者重命名刚才创建的Mariadb.repo文件 12cd /etc/yum.repos.dmv Mariadb.repo Mariadb.repo.bak (2) 然后一条命令安装Mariadb 1yum install mariadb-server mariadb -y 5 启动mariadb命令mariadb数据库的相关命令是： 1234systemctl start mariadb # 启动MariaDBsystemctl stop mariadb # 停止MariaDBsystemctl restart mariadb # 重启MariaDBsystemctl enable mariadb # 设置开机启动 6 初始化mysql1mysql_secure_installation 7 使用mysql命令进入数据库1mysql -u root -p 8 mysql基本操作12345671 创建数据库2 创建表create table qishitb (id int, name char(11));3 插入数据insert into qishitb values(1, \"陈鹏\");4 查看数据select * from qishitb; 12345查看数据库的信息\\s查看表的编码信息show create table qishitb 9 解决中文乱码问题(1) 修改配置文件 1vim /etc/my.cnf (2) 添加以下配置文件(如图) 12345678[mysqld]character-set-server=utf8collation-server=utf8_general_cilog-error=/var/log/mysqld.log[client]default-character-set=utf8[mysql]default-character-set=utf8 (3) 重启数据库 1systemctl restart mariadb","categories":[{"name":"数据库","slug":"数据库","permalink":"https://zo.subo.xyz/categories/数据库/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://zo.subo.xyz/tags/linux/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-08-14T13:26:19.352Z","updated":"2019-08-10T03:46:53.049Z","comments":true,"path":"2019/08/14/hello-world/","link":"","permalink":"https://zo.subo.xyz/2019/08/14/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"Python-代码优化","slug":"Python优化","date":"2019-08-14T02:33:42.000Z","updated":"2019-08-14T09:53:52.769Z","comments":true,"path":"2019/08/14/Python优化/","link":"","permalink":"https://zo.subo.xyz/2019/08/14/Python优化/","excerpt":"","text":"序言：在日常的工作中可能需要或多少对一些已经写好的代码的性能不满意，或者代码冗余，所以就记录一下在平常开发中对代码的一些优化，如果有不足或者错误的地方，欢迎指正。 当使用for循环的时候，不需要用到每次循环的变量的时候，直接使用“_”占位符，省去一个变量的地址 正常代码12for i in range（10000）： pass 优化代码12for _ in range（10000）：pass 当我们不需要for遍历的值的时候，可以使用占位符 代替，可以节约内存。","categories":[{"name":"Python","slug":"Python","permalink":"https://zo.subo.xyz/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://zo.subo.xyz/tags/Python/"}]},{"title":"Redis的搭建集群","slug":"redis-安装及配置哨兵模式","date":"2019-08-13T02:33:42.000Z","updated":"2019-08-14T09:49:04.355Z","comments":true,"path":"2019/08/13/redis-安装及配置哨兵模式/","link":"","permalink":"https://zo.subo.xyz/2019/08/13/redis-安装及配置哨兵模式/","excerpt":"","text":"序言：在日常的工作中可能需要或多 Redis 安装:使用源码安装或者yum安装 1234567yum install redis -y或者wget http://download.redis.io/releases/redis-4.0.10.tar.gztar xzf redis-4.0.10.tar.gzcd redis-4.0.10make &amp;&amp; make install Centos安装redis1.下载redis源码1wget http://download.redis.io/releases/redis-4.0.10.tar.gz 2.解压缩1tar -zxf redis-4.0.10.tar.gz 3.切换redis源码目录1cd redis-4.0.10 4.编译源文件1make 5.编译好后，src/目录下有编译好的redis指令6.make install 安装到指定目录，默认在/usr/local/bin1make install 7 创建一个redis的配置文件redsi-6379.conf123mkdir -p /opt/redis_confcd /opt/redis_confvim redis-6379.conf 添加以下配置: 12345678port 6379 daemonize yes pidfile /data/6379/redis.pidloglevel notice logfile &quot;/data/6379/redis.log&quot;dir /data/6379 protected-mode yes requirepass haohaio 123456789# redis配置文件详解port 6379 # 运行在6379的redis数据库实例daemonize yes # 后台运行redis pidfile /data/6379/redis.pid # 存放redis pid的文件loglevel notice # 日志等级logfile &quot;/data/6379/redis.log&quot; # 指定redis日志文件的生成目录dir /data/6379 # 指定redis数据文件夹的目录protected-mode yes # 安全模式requirepass haohaio # 设置redis的密码 8 创建相应的目录:1mkdir -p /data/6379 9 启动redis1redis-server /opt/redis_conf/redis-6379.conf ### redis的日志等级(loglevel) 123456789Redis默认的设置为verbose，开发测试阶段可以用debug，生产模式一般选用notice1. debug：会打印出很多信息，适用于开发和测试阶段2. verbose（冗长的）：包含很多不太有用的信息，但比debug要清爽一些3. notice：适用于生产模式4. warning : 警告信息 启动redis(两种方式) 直接执行redis-server命令 1此命令加载默认的配置文件,也就是启动一个端口为6379的redis数据库 使用加载配置文件方式启动redis数据库 配置文件详解 12345678 port 6379 # 设定运行的端口 daemonize yes # 后台运行redis (启用守护进程) pidfile /data/6379/redis.pid # 存放redis pid的文件loglevel notice # 日志等级logfile &quot;/data/6379/redis.log&quot; # 指定redis日志文件的生成目录dir /data/6379 # 指定redis数据文件夹的目录protected-mode yes # 安全模式requirepass haohaio # 设置redis的密码 具体命令 1redis-server /redis_conf/redis-6280.conf Redis服务的关闭及重启使用redis内置的命令shutdown 可以关掉指定的服务 123redis-cli -h 127.0.0.1 -p 6380 shutdownredis-cli -h 127.0.0.1 -p 6381 shutdownredis-cli -h 127.0.0.1 -p 6382 shutdown 也可以使用redis-server restart(但是此方法只能对默认的6379端口有效) redis-server stop 停止redis服务(6379) redis-server start 启动redis服务(6379) redis-server restart 重启redis服务(6379) Redis客户端客户端是如何连接到服务端呢?​ 使用redis -cli 命令 redis-cli 参数详解1234redis-cli -p 6380 -a zhuanqq -p 设置redis链接的端口 -a 显示的填写密码 --raw 使用原始格式 Redis 参数文件配置详细Redis配置文件参数说明配置文件参数说明: (1) Redis默认不是以守护进程的方式运行，可以通过该配置项修改，使用yes启用守护进程 1daemonize no (2) 当Redis以守护进程方式运行时，Redis默认会把pid写入/var/run/redis.pid文件，可以通过pidfile指定 1pidfile /var/run/redis.pid (3) 指定Redis监听端口，默认端口为6379，作者在自己的一篇博文中解释了为什么选用6379作为默认端口，因为6379在手机按键上MERZ对应的号码，而MERZ取自意大利歌女Alessia Merz的名字 1port 6379 (4) 绑定的主机地址 1bind 127.0.0.1 (5)当 客户端闲置多长时间后关闭连接，如果指定为0，表示关闭该功能 1timeout 300 (6)指定日志记录级别，Redis总共支持四个级别：debug、verbose、notice、warning，默认为verbose 1loglevel verbose (7) 日志记录方式，默认为标准输出，如果配置Redis为守护进程方式运行，而这里又配置为日志记录方式为标准输出，则日志将会发送给/dev/null logfile stdout(8) 设置数据库的数量，默认数据库为0，可以使用SELECT 命令在连接上指定数据库id 1databases 16 (9) 指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合 ​ save ​ Redis默认配置文件中提供了三个条件： 12345save 900 1save 300 10save 60 10000 分别表示900秒（15分钟）内有1个更改，300秒（5分钟）内有10个更改以及60秒内有10000个更改。 (10) 指定存储至本地数据库时是否压缩数据，默认为yes，Redis采用LZF压缩，如果为了节省CPU时间，可以关闭该选项，但会导致数据库文件变的巨大 1rdbcompression yes (11) 指定本地数据库文件名，默认值为dump.rdb 1dbfilename dump.rdb (12) 指定本地数据库存放目录 1dir ./ (13) 设置当本机为slav服务时，设置master服务的IP地址及端口，在Redis启动时，它会自动从master进行数据同步 1slaveof &lt;masterip&gt; &lt;masterport&gt; (14) 当master服务设置了密码保护时，slav服务连接master的密码 1masterauth &lt;master-password&gt; (15) 设置Redis连接密码，如果配置了连接密码，客户端在连接Redis时需要通过AUTH 命令提供密码，默认关闭 1requirepass foobared (16) 设置同一时间最大客户端连接数，默认无限制，Redis可以同时打开的客户端连接数为Redis进程可以打开的最大文件描述符数，如果设置 maxclients 0，表示不作限制。当客户端连接数到达限制时，Redis会关闭新的连接并向客户端返回max number of clients reached错误信息 1maxclients 128 (17) 指定Redis最大内存限制，Redis在启动时会把数据加载到内存中，达到最大内存后，Redis会先尝试清除已到期或即将到期的Key，当此方法处理 后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作。Redis新的vm机制，会把Key存放内存，Value会存放在swap区 1maxmemory &lt;bytes&gt; (18) 指定是否在每次更新操作后进行日志记录，Redis在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断电时导致一段时间内的数据丢失。因为 redis本身同步数据文件是按上面save条件来同步的，所以有的数据会在一段时间内只存在于内存中。默认为no 1appendonly no (19) 指定更新日志文件名，默认为appendonly.aof 1appendfilename appendonly.aof (20) 指定更新日志条件，共有3个可选值： ​ no：表示等操作系统进行数据缓存同步到磁盘（快）​ always：表示每次更新操作后手动调用fsync()将数据写到磁盘（慢，安全）​ everysec：表示每秒同步一次（折衷，默认值） 1appendfsync everysec (21) 指定是否启用虚拟内存机制，默认值为no，简单的介绍一下，VM机制将数据分页存放，由Redis将访问量较少的页即冷数据swap到磁盘上，访问多的页面由磁盘自动换出到内存中（在后面的文章我会仔细分析Redis的VM机制） 1vm-enabled no (22) 虚拟内存文件路径，默认值为/tmp/redis.swap，不可多个Redis实例共享 1vm-swap-file /tmp/redis.swap (23) 将所有大于vm-max-memory的数据存入虚拟内存,无论vm-max-memory设置多小,所有索引数据都是内存存储的(Redis的索引数据 就是keys),也就是说,当vm-max-memory设置为0的时候,其实是所有value都存在于磁盘。默认值为0 1vm-max-memory 0 (24) Redis swap文件分成了很多的page，一个对象可以保存在多个page上面，但一个page上不能被多个对象共享，vm-page-size是要根据存储的 数据大小来设定的，作者建议如果存储很多小对象，page大小最好设置为32或者64bytes；如果存储很大大对象，则可以使用更大的page，如果不 确定，就使用默认值 1vm-page-size 32 (25) 设置swap文件中的page数量，由于页表（一种表示页面空闲或使用的bitmap）是在放在内存中的，，在磁盘上每8个pages将消耗1byte的内存。 1vm-pages 134217728 (26) 设置访问swap文件的线程数,最好不要超过机器的核数,如果设置为0,那么所有对swap文件的操作都是串行的，可能会造成比较长时间的延迟。默认值为4 1vm-max-threads 4 (27) 设置在向客户端应答时，是否把较小的包合并为一个包发送，默认为开启 1glueoutputbuf yes (28) 指定在超过一定的数量或者最大的元素超过某一临界值时，采用一种特殊的哈希算法 123hash-max-zipmap-entries 64hash-max-zipmap-value 512 (29) 指定是否激活重置哈希，默认为开启（后面在介绍Redis的哈希算法时具体介绍） 1activerehashing yes (30) 指定包含其它的配置文件，可以在同一主机上多个Redis实例之间使用同一份配置文件，而同时各个实例又拥有自己的特定配置文件 1include /path/to/local.conf [Redis protected-mode属性解读](https://www.cnblogs.com/kingsonfu/p/10138647.html) (31) redis3.2版本后新增protected-mode配置，默认是yes，即开启。设置外部网络连接redis服务，设置方式如下： 1231) 关闭protected-mode模式，此时外部网络可以直接访问2) 开启protected-mode保护模式，需配置bind ip或者设置访问密码 Redis数据库的数据类型(五种)123456redis是一种高级的key：value存储系统，其中value支持五种数据类型字符串（strings）散列（hashes）列表（lists）集合（sets）有序集合（sorted s 1.string字符串类型 set 设置key(当已经存在key时,会覆盖此key的value) 1127.0.0.1:6379&gt; set name 'tt' get 获取key(获取不存在的value，为nil) 1127.0.0.1:6379&gt; get name append 追加string 1127.0.0.1:6379&gt; append name 'shadiao' mset 设置多个键值对 1127.0.0.1:6379&gt; mset key1 'value1' key2 'value2' mget 获取多个键值对 1127.0.0.1:6379&gt; mget key1 key2 del 删除key 1127.0.0.1:6379&gt; del key1 string类型实际上不仅仅包括字符串类型，还包括整型,浮点型. redis可对整个字符串或字符串一部分进行操作，而对于整型/浮点型可进行自增、自减操作。 incr 递增+1 123127.0.0.1:6379&gt; set num '10'127.0.0.1:6379&gt; incr num(integer) 11 decr 递减-1 12127.0.0.1:6379&gt; decr num(integer) 9 2.list类型 lpush 从列表左边插 123## 从左侧依次放入下面三个元素(如果不存在,则自动创建 此列表)127.0.0.1:6379&gt; lpush listsname 'alex' 'jinjiao' 'dawang'(integer) 2 rpush 从列表右边插 123##从右侧依次放入下面三个元素(如果不存在,则自动创建 此列表)127.0.0.1:6379&gt; rpush listsname 'alex' 'jinjiao' 'dawang'(integer) 2 llen 查看列表长度 123### 查看名为listname的列表的长度127.0.0.1:6379&gt; llen listname(integer) 3 lrange 获取一定长度的元素 lrange key start stop 12##查看列表所有的元素127.0.0.1:6379&gt; lrange duilie 0 -1 ltrim 截取一定长度列表 12## 截取列表固定长度, 删除其他的元素(只保留截取出来的元素,其余全del掉)127.0.0.1:6379&gt; lrange duilie 0 -1 lpop 删除最左边一个元素 1127.0.0.1:6379&gt; lpop duilie rpop 删除最右边一个元素 1127.0.0.1:6379&gt; rpop duilie lpushx/rpushx key存在则添加值，不存在不处理 1### 用法与lpush一样,只是当这个列表存在的时候,则就去添加,不存在则不执行 3.set 集合类型redis的集合，是一种无序的集合，集合中的元素没有先后顺序。 集合相关的操作也很丰富，如添加新元素、删除已有元素、取交集、取并集、取差集等。我们来看例子： sadd/srem 添加/删除 元素 sismember 判断是否为set的一个元素 smembers 返回集合所有的成员 sdiff 返回一个集合和其他集合的差异 sinter 返回几个集合的交集 sunion 返回几个集合的并集 123456789101112131415161718192021sadd zoo wupeiqi yuanhao #添加集合，有三个元素，不加引号就当做字符串处理smembers zoo #查看集合zoo成员srem zoo wupeiqi #删除zoo里面的alexsismember zoo wupeiqi #返回改是否是zoo的成员信息，不存在返回0，存在返回1sadd zoo wupeiqi #再把wupeiqi加入zoosmembers zoo #查看zoo成员sadd zoo2 wupeiqi mjj #添加新集合zoo2sdiff zoo zoo2 #找出集合zoo中有的，而zoo2中没有的元素sdiff zoo2 zoo #找出zoo2中有，而zoo没有的元素sinter zoo zoo1 #找出zoo和zoo1的交集，都有的元素sunion zoo zoo1 #找出zoo和zoo1的并集，所有的不重复的元素 4.哈希类型数据hashes即哈希。哈希是从redis-2.0.0版本之后才有的数据结构。 hashes存的是字符串和字符串值之间的映射，hash特别适合用于存储对象，比如一个用户要存储其全名、姓氏、年龄等等，就很适合使用哈希。 Redis 中每个 hash 可以存储 232 - 1 键值对（40多亿）。 1Hash，一般翻译做散列、杂凑，或音译为哈希，是把任意长度的输入通过散列算法变换成固定长度的输出，该输出就是散列值。这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，所以不可能从散列值来确定唯一的输入值。简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。 hset 设置散列值 hget 获取散列值 hgetall获取在哈希表中指定 key 的所有字段和值 hmset 设置多对散列值 hmget 获取多对散列值 hsetnx 如果散列已经存在，则不设置（防止覆盖key） hkeys 返回所有keys hvals 返回所有values hlen 返回散列包含域（field）的数量 hdel 删除散列指定的域（field） hexists 判断是否存在 1234567891011121314151617181920212223242526272829redis hash是一个string类型的field和value的映射表语法 hset key field value hset news:1 title \"first news title\" #设置第一条新闻 news的id为1，添加数据title的值是\"first news title\"hset news:1 content \"news content\" #添加一个conntent内容hget news:1 title #获取news:1的标题hget news:1 content #获取news的内容hmget news:1 title content #获取多对news:1的 值hmset news:2 title \"second news title\" content \"second Contents2\" #设置第二条新闻news:2 多个fieldhmget news:2 title content #获取news:2的多个值hkeys news:1 #获取新闻news:1的所有keyhvals news:1 #获取新闻news:1的所有值hlen news:1 #获取新闻news:1的长度hdel news:1 title #删除新闻news:1的titlehlen news:1 #看下新闻news:1的长度hexists news:1 title #判断新闻1中是否有title，不存在返回0，存在返回1 Redis 持久化redis持久化一共分为两种: RDB持久化 AOF持久化 1.RDB持久化在RDB模式下.你有两种选择,一种是手动选择持久化命令save bsave来让redis进行一次数据快照,另一种则是将根据配置文件中所配置的策略进行 2.AOF持久化Redis订阅https://raw.githubusercontent.com/chenluzhong150394/git-tools/master/my_2.jpg Redis 配置主从同步(普通模式)1.准备三个redis 数据库 ,redis支持多实例(端口不同即可) 12# 主服务器: master:6380#从服务器: slave : 6381,6382 2.配置主服务器master的配置文件 1vim /opt/redis_conf/redis-6380.conf 添加以下配置 12345678port 6380daemonize yespidfile /data/6380/redis.pidloglevel noticelogfile &quot;/data/6380/redis.log&quot;dbfilename dump.rdb ##指定本地数据库文件的名字dir /data/6380 ##指定数据库文件的存放目录protected-mode no ##配置外部网络可以直接访问 (3) 再创建另外两个从服务器的配置文件 6381 12345678910vim /opt/redis_conf/redis-6381.conf添加以下配置port 6381daemonize yespidfile /data/6381/redis.pidloglevel noticelogfile &quot;/data/6381/redis.log&quot;dbfilename dump.rdbdir /data/6381protected-mode no 6382 12345678910vim /opt/redis_conf/redis-6382.conf添加以下配置port 6382daemonize yespidfile /data/6382/redis.pidloglevel noticelogfile &quot;/data/6382/redis.log&quot;dbfilename dump.rdbdir /data/6382protected-mode no (4) 创建数据存储目录 1mkdir -p /data/&#123;6380,6381,6382&#125; (5) 先启动三个数据库，查看数据库是否正常 123redis-server /opt/redis_conf/redis-6380.confredis-server /opt/redis_conf/redis-6381.confredis-server /opt/redis_conf/redis-6382.conf (6) 分别连接三个数据库，分别添加数据，确认这三个数据库是独立的数据库 (7) 配置主从(注意只需要在两个从库上配置即可) 1slaveof 127.0.0.1 6380 (8) 重启redis服务 123456789#先关掉redis 服务redis-cli -h 127.0.0.1 -p 6380 shutdownredis-cli -h 127.0.0.1 -p 6381 shutdownredis-cli -h 127.0.0.1 -p 6382 shutdown# 再次启动redis服务redis-server /opt/redis_conf/redis-6380.confredis-server /opt/redis_conf/redis-6381.confredis-server /opt/redis_conf/redis-6382.conf (9)启动服务后重新在从库启动主从开关 1slaveof 127.0.0.1 6380 (9) 查看主从服务器的状态 1redis-cli -p 6380 info replication 6380 1# 可以查看到6380的角色为master, 下面有两个从库，我们主要查看这两个从库的状态为online，说明主从同步配置成功 6381 6382 3. 手动进行主从复制故障切换(1)手动结束掉6380的进程，模拟主库宕机 (2) 在从库6381和6382上查看状态, 可以查看到master的状态为down 1127.0.0.1:6381&gt; info replication 既然主库挂了，我想要在6381 6382之间选一个新的主库 1.关闭6381的从库身份 123redis-cli -p 6381info replicationslaveof no one 2.将6382设为6381的从库 12346382连接到6381：[root@db03 ~]# redis-cli -p 6382127.0.0.1:6382&gt; slaveof no one127.0.0.1:6382&gt; slaveof 127.0.0.1 6381 3.检查6382，6381的主从信息 4.修改完毕，还得修改配置文件，永久生效 6381: 6382: 手动故障切换的原理呢,就是重新配置一下主从关系,将原来的主库踢出去,如果能再次启动的话,就可以加入从库,所以这种方法,真的是很沙雕,没人用的.所以我们使用哨兵,进行监控,并自动进行投票切换主库. Redis配置主从(哨兵模式)","categories":[{"name":"数据库","slug":"数据库","permalink":"https://zo.subo.xyz/categories/数据库/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://zo.subo.xyz/tags/linux/"},{"name":"Redis","slug":"Redis","permalink":"https://zo.subo.xyz/tags/Redis/"}]},{"title":"数据库常用操作","slug":"l数据库","date":"2019-08-10T05:52:50.000Z","updated":"2019-08-12T01:03:24.833Z","comments":true,"path":"2019/08/10/l数据库/","link":"","permalink":"https://zo.subo.xyz/2019/08/10/l数据库/","excerpt":"","text":"数据库操作数据库的基本操作修改root密码1alter user root identifiled by password &apos;password&apos; MySQL修改用户的密码主要有两种方法：ALTER USER 和SET PASSWORD ALTER USER基本使用 1ALTER USER testuser IDENTIFIED BY &apos;123456&apos;; 修改当前登录用户 1ALTER USER USER() IDENTIFIED BY &apos;123456&apos;; 使密码过期 1ALTER USER testuser IDENTIFIED BY &apos;123456&apos; PASSWORD EXPIRE; 使密码从不过期 1ALTER USER testuser IDENTIFIED BY &apos;123456&apos; PASSWORD EXPIRE NEVER; 按默认设置过期时间 1ALTER USER testuser IDENTIFIED BY &apos;123456&apos; PASSWORD EXPIRE DEFAULT; 指定过期间隔 1ALTER USER testuser IDENTIFIED BY &apos;123456&apos; PASSWORD EXPIRE INTERVAL 90 DAY; 在MySQL文档里，推荐使用ALTER USER修改用户密码 SET PASSWORD使用SET PASSWORD的password有两种： 使用默认加密 1SET PASSWORD FOR testuser = &apos;123456&apos; 使用PASSWORD()函数加密 1SET PASSWORD FOR testuser = PASSWORD(&quot;123456&quot;) 增删查改增加1、增加一个字段 1insert 2、增加一条记录 12 3、在多表关联的情况下，新增一条数据 12 删除1、删除一个字段 12 2、删除一条记录 12 3、删除多表中相关联的数据 12 更新1、更新一个字段名（在不改变原来数据的情况下） 12 2、更新一条数据中的某个字段的数据 12 3、在多表关联的情况下更新相关联的字段数据 12 查询1、单表查询（查询满足特定条件的所有数据） 12 2、使用左连接查询多表 12 修改1、给字段添加注释 12345#### 创建表的时候加注释create table test1(name char(32) comment&apos;字段注释&apos;) comment=‘表注释’；### 修改某个字段的属性并加上注释ALTER table table_name MODIFY `column_name` datetime DEFAULT NULL COMMENT &apos;这是字段的注释&apos; 2、给表加注释 1alter table table_name comment=&apos;这是表的注释&apos;","categories":[{"name":"数据库","slug":"数据库","permalink":"https://zo.subo.xyz/categories/数据库/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://zo.subo.xyz/tags/linux/"}]},{"title":"Shadowsocet配置多端口","slug":"shadowscoket 配置多端口 (需要配置防火墙)","date":"2019-08-10T05:52:50.000Z","updated":"2019-08-10T17:18:04.135Z","comments":true,"path":"2019/08/10/shadowscoket 配置多端口 (需要配置防火墙)/","link":"","permalink":"https://zo.subo.xyz/2019/08/10/shadowscoket 配置多端口 (需要配置防火墙)/","excerpt":"","text":"shadowscoket 配置多端口 (需要配置防火墙)先将要设置的端口在firewall防火墙放行 12firewall-cmd --zone=public --add-port=52300/tcp --permanent firewall-cmd --zone=public --add-port=52300/udp --permanent 查看firewall 开放的所有端口 1firewall-cmd --zone=public --list-ports 然后去将原来的shadowscoket配置文件进行备份 1cp /etc/shadowsocks.json /etc/shadowsocks.json.bak 然后打开配置文件替换成以下内容 1vim /etc/shadowsocks.json 1234567891011121314&#123;&quot;server&quot;:&quot;0.0.0.0&quot;,&quot;local_address&quot;:&quot;127.0.0.1&quot;,&quot;local_port&quot;:1080,&quot;port_password&quot;:&#123;&quot;52300&quot;:&quot;chenshuo003&quot;,&quot;52500&quot;:&quot;chenshuo003&quot;&#125;,&quot;obfs&quot;:&quot;plain&quot;,&quot;obfs_param&quot;:&quot;&quot;,&quot;timeout&quot;:300,&quot;method&quot;:&quot;aes-256-cfb&quot;,&quot;fast_open&quot;: false&#125; 然后重启shadowsocket服务并查看状态 1234# 重启服务/etc/init.d/shadowsocks restart## 查看服务状态/etc/init.d/shadowsocks status 重启锐速 12345## 重启锐速service serverSpeeder restart##查看锐速状态service serverSpeeder status 查看当前端口有多少IP链接(脚本有后台,需要手动禁止ip–hosts.deny) 使用netstat 命令 1netstat -anp | grep 52300 找到链接的ip,只要不是自己的,全部禁了 1234### 打开hosts.deny文件vim /etc/hosts.deny ### 将想要禁止的ip添加上去125.23.223.2 然后重启网卡服务,使hosts.deny文件生效 1systemctl restart network","categories":[{"name":"Linux","slug":"Linux","permalink":"https://zo.subo.xyz/categories/Linux/"}],"tags":[{"name":"Shadowsocet","slug":"Shadowsocet","permalink":"https://zo.subo.xyz/tags/Shadowsocet/"}]},{"title":"flask笔记","slug":"flask笔记","date":"2019-08-10T05:52:50.000Z","updated":"2019-08-10T17:17:33.919Z","comments":true,"path":"2019/08/10/flask笔记/","link":"","permalink":"https://zo.subo.xyz/2019/08/10/flask笔记/","excerpt":"","text":"FLASK 安装先创建一个虚拟环境，并使用pycharm 初始化一个pure python项目 1mkvirtualenv flask_demo -p python3 1pip install flask==0.12.4 flask的简单组成 初始化flask ==》 路由 创建一个flask 应用 12## 创建flask 应用app = Flask(__name__) 路由-限定请求方式 1234567891011@app.route('/')def idnex(): return '这里是首页'##路由-限定请求方式## route 中有个参数methods 是定义请求类型的，只有定义了才能访问，#默认的是开启get的@app.route('/',methods=[\"get\",\"post\"])def idnex(): return '这里是首页' 开启debug模式 1DEBUG = True 在主文件导入配置文件 123456class Config(object) DEBUG = True app.config.from_object(Config)## 最常用的方式是通过对象的方式， 通过导包，将配置文件加载 启动flask 123456app.run(host='localhost',port=8080,debug=true) # flask 内部作为一个基本的web框架，内置http服务器肯定有的。 #运行flask 可以使用 app.run（） # host 服务器启动时绑定的域名 #port 服务器启动时绑定的端口 #debug 是否开启调试模式 简单的flask demo详解在路由中设置变量（传递参数-两种）123456789101112## 使用'&lt; &gt;' 表示变量名，##&lt;int:变量名&gt;表示限制变量的数据类型@app.route(\"/user/&lt;int:userid&gt;\")def user(userid): return \"用户个人中心%s\" % userid\"\"\"限制参数类型int:变量名 #当前路由内容只能是整型float:变量名 #当前路由内容只能是 浮点数path:变量名 #当前路由内容可以是任何内容\"\"\" 正则匹配路由1.首先导入转换器基类 1from werkzeug.routing import BaseConverter 2.自定义转换器 123456class RegexCover(BaseConverter): def __init__(self, map,*args): super(RegexCover,self).__init__(map) ## 正则参数 self.regex = args[0] 3.将自定义的转换器添加到转换器字典中，并指定转换器使用的别名 1app.url_map.converters['regex'] = RegexCover 4.就可以通过正则去获取参数变量了 1234## regex 后面跟一个元组，元祖里面是正则表达式，mobile是变量名@app.route(\"/user/&lt;regex('\\d+'):mobile&gt;\")def user(mobile): return \"用户手机号%s\" % mobile 预定义正则匹配路由可以直接讲正则(regex)写死,然后直接用就行了一般应用场景是 固定类型的正则（验证手机号的合法等等） 1234567891011## 声明一个固定转换器class Mobileter(BaseConverter): regex = \"1[3-9]\\d&#123;9&#125;\" ## 将上面的转化器注册到转化器字典中app.url_map.converters['mobile'] = Mobileter##使用自定义的转换器，@app.route(\"/user/&lt;mobile:mobile&gt;\")def user(mobile): return \"用户手机号%s\" % mobile 系统自带转换器 werkzeug.routing.py 123456789DEFAULT_CONVERTERS = &#123; \"default\": UnicodeConverter, \"string\": UnicodeConverter, \"any\": AnyConverter, \"path\": PathConverter, \"int\": IntegerConverter, \"float\": FloatConverter, \"uuid\": UUIDConverter,&#125; http的请求与响应在flask中导入 request 模块，用request模块去获取客户端提交的数据 常用的属性如下： 属性 说明 类型 data 记录请求的数据，并转换为字符串 * form 记录请求中的表单数据 MultiDict args 记录请求中的查询参数 MultiDict cookies 记录请求中的cookie信息 Dict headers 记录请求中的请求头 EnvironHeaders method 记录请求使用的HTTP方法 GET/POST url 记录请求的URL地址 string files 记录请求上传的文件 * json 记录请求的json数据 json 响应 Flask 默认支持两种响应方式 数据响应： 默认响应html，也可以返回json 页面响应：重定向 url_for 响应的时候，flask也支持自定义响应状态码 响应html文本 12345## 路由@app.route(\"/\")def index(): # [默认支持]响应html文本 return \"&lt;img src='https://palletsprojects.com/logo-large.png'&gt;\" 返回JSON数据 在flask中可以直接使用jsonify 生成一个json的响应 123456789101112from flask import Flask, request, jsonify@app.route(\"/\")def index(): # 也可以响应json格式代码 data = [ &#123;\"id\":1,\"username\":\"liulaoshi\",\"age\":18&#125;, &#123;\"id\":2,\"username\":\"liulaoshi\",\"age\":17&#125;, &#123;\"id\":3,\"username\":\"liulaoshi\",\"age\":16&#125;, &#123;\"id\":4,\"username\":\"liulaoshi\",\"age\":15&#125;, ] return jsonify(data) 重定向 重定向到站外页面 123456from flask import Flask,request,jsonify,redirect@app.route(\"/\")def index(): # 页面跳转响应 return redirect('http://www.baidu.com') 重定向到自己写的视图函数 也可以直接填写自己的url路径 也可以使用url_for 生成指定视图函数所对应url 1234567891011@app.route(\"/user\")def user(): # 页面跳转响应 userid = None return 'userid %s' % userid## 路由@app.route(\"/\")def index(): # 页面跳转响应 return redirect(url_for('user')) ## 这里的user 是上面的user函数 url_for 12345#使用url_for可以实现视图方法之间的内部跳转# url_for(\"视图方法名\")@app.route(\"/login\")def login(): return redirect( url_for(\"index\") ) 重定向到带有参数的视图函数 在url_for 函数中传入参数 1234567891011## 路由传递参数@app.route(\"/user/&lt;userid&gt;\")def user(userid): # 页面跳转响应 return 'userid %s' % userid# 重定向@app.route(\"/\")def index(): # 使用url_for 生成指定视图函数所对应的url return redirect(url_for('user',userid=100)) 自定义状态码 在flask 中，可以很方便的返回自定义状态码，以实现不符合http协议的状态吗，例如：status code :666 123@app.route('/demo4')def demo4(): return '状态码为 666', 400 会话控制实现状态保持的两种方式： 在客户端存储信息使用Cookie本地存储，token[jwt.,auth] 在服务器端存储信息使用Session，redis 设置Cookieflask框架提供了一个make_responce 函数来快速创建响应对象 12345678## 首先实例化一个make_responce对象，传入的参数是响应对象的主体## 去给这个响应对象设置cookies， 传入key，value，过期时间## 最后将这个对象retrun ge给客户端@app.route(\"/\")def set_cookie(): resp = make_response('this is set cookie') resp.set_cookie('usename','xiaoming',max_age=3600) return resp 获取Cookie1234@app.route(\"/get\")def get_cookie(): resp = request.cookies.get('username') return resp Session 在服务器段进行状态保存的方案就是Session 注意：Session依赖于Cookie，而且flask中使用session，需要配置SECRET_KEY 选项，否则报错 设置session12345678910111213## 首先设置SECRET_KEY class Config(object): SECRET_KEY = '1231fddfds213'app.config.from_object(Config)## 然后从flask中导入session模块from flask import session## 定义视图函数@app.route(\"/set\")def set(): session['uname'] = 'xiaoming' return 'ok' 获取session12345## 直接使用session.get(ket)这个函数取得存储的session@app.route(\"/get\")def get(): resp = session.get('uname') return res 上下文flask中上下文的分为两种上下文：即语境，语意，在程序中可以理解为在代码执行到某一时刻时，根据之前代码所做的操作以及下文即将要执行的逻辑，可以决定在当前时刻下可以使用到的变量，或者可以完成的事情。 Flask中有两种上下文，请求上下文(request context)和应用上下文(application context)。 Flask中上下文对象：相当于一个容器，保存了 Flask 程序运行过程中的一些信息[变量、函数、类与对象等信息] application 指的就是当你调用app = Flask(__name__)创建的这个对象app； request 指的是每次http请求发生时，WSGI server(比如gunicorn)调用Flask.__call__()之后，在Flask对象内部创建的Request对象； application 表示用于响应WSGI请求的应用本身，request 表示每次http请求； application的生命周期大于request，一个application存活期间，可能发生多次http请求，所以，也就会有多个request 请求上下文对象 request 123Flask的请求上下文，包含请求变量如:method、args、form、values、endpoint、headers、remote_addr都是比较常用的。 例如 ： request.args.get ('user' ) 获取get请求参数 session 1Flask的请求上下文，用于存放用户的会话信息。 应用上下文对象 current_app 1Flask的应用上下文，返回当前app的方法和属性，可以勉强理解为类全局变量。 g 1234 作为Flask 程序全局中的一个临时变量 不同的请求有不同的全局变量g简单来说这个临时变量的生命周期就是一次请求，。 只在当前请求中共享变量 两者区别： 请求上下文：保存了客户端和服务器交互的数据 应用上下文：flask 应用程序运行过程中，保存的一些配置信息，比如程序名、数据库连接、应用信息等 请求钩子flask的四种请求钩子（又称网络拦截器） before_first_request 在处理第一个请求之前执行（项目初始化的钩子） 应用场景：开启数据库链接，等等 before_request 在每次请求前执行 如果在某修饰函数中返回了一个响应，视图函数将不再被调用 应用场景： 做jwt 或者auth 权限认证， 如果不通过则返回一个响应对象，这样下面的视图函数就不走了。 after_request 必须接收一个response的参数，是请求执行的视图函数的返回对象 如果没有抛出错误，在每次请求后执行 接受一个参数： 将视图函数的作出的响应对象传入 在此函数中可以对响对象中的值在返回之前做最后一部修改处理 需要将参数中的响应子啊此参数中进行返回 teardown_request 严格来说，没有固定请求的位置，只有请求上下文被pop出栈的时候就会出发这个，所以即使之前有跑出错误都会执行，通俗一点就是当 在视图内部报错之后执行 接受一个参数： 错误信息，如果有相关错误抛出 需要设置flask的配置DEBUG=False，teardown_request才会接受到异常对象。 可以通过request 方法，进行对请求的url及参数或者文件的提取，再进行逻辑判断，从而决定钩子的流程控制及返回值 after_request 必须接收一个response的参数，是请求执行的视图函数的返回对象1234567891011121314## 请求对应的视图函数执行后＝要执行的钩子函数，在返回客户端之前@app.after_requestdef after_request(responce): print('－－－请求执行后需要执行的钩子函数－－－') print('－－－主要作用就是对视图函数返回的值到客户端之前进行再此的修饰－－－') print(responce.data) return responce#路由@app.route(\"/\")def user(): # 页面跳转响应 print('----视图函数-----') return 'ok' teardown_request 当视图中报错时候就会触发teardown请求钩子，必须要一个参数接收异常信息 1234## 在视图内，抛出异常就会执行@app.teardown_requestdef teardown_request(exc): print('exc %s' % exsc ) 异常捕获主动抛出HTTP异常 abort方法 抛出一个给定状态码的HTTPException或者指定响应，列如想要用一个页面未找到异常来终止请求，你可以调用abort(404) 参数： code -HTTP 的错误状态码 12# abort(404)abort(500) 抛出状态码的话，只能抛出HTTP协议的错误状态吗 捕获错误 errorhandler 装饰器 注册一个错误处理程序，当检测到程序抛出指定错误状态吗的时候，就会调用该装饰器所装饰的方法 参数 code_or_exception-HTTP 的错误状态吗或指定异常 例如，统一处理“页面找不到”，状态码为500 ，给用户友好的提示 1234@app.errorhandler(404)def error_404(error): print(error) return \"&lt;img src=https://raw.githubusercontent.com/chenluzhong150394/img/master/1.png &gt;\" 捕获指定异常类型 123@app.errorhandler(ZeroDivisionError)def zero_division_error(e): return '除数不能为0' 实例 1234567891011121314151617181920212223242526272829303132333435from flask import Flaskfrom settings.dev import Config# 创建flask应用app = Flask(__name__)\"\"\"加载配置\"\"\"app.config.from_object(Config)\"\"\"flask中内置了app.errorhander提供给我们捕获异常，实现一些在业务发生错误时的自定义处理。1. 通过http状态码捕获异常信息2. 通过异常类进行异常捕获\"\"\"\"\"\"1. 捕获http异常[在装饰器中写上要捕获的异常状态码也可以是异常类]\"\"\"@app.errorhandler(404)def error_404(e): return \"&lt;h1&gt;您访问的页面失联了！&lt;/h1&gt;\"\"\"\"2. 捕获系统异常或者自定义异常\"\"\"class APIError(Exception): pass@app.route(\"/\")def index(): raise APIError(\"api接口调用参数有误！\") return \"个人中心，视图执行了！！\"@app.errorhandler(APIError)def error_apierror(e): return \"错误: %s\" % eif __name__ == '__main__': app.run(host=\"localhost\",port=8080) Flask-Script扩展安装命令：1pip install flask-script 集成 Flask-Script到flask应用中，创建一个主应用程序，一般我们叫manage.py 配置脚手架使其能通过终端运行项目12345678910111213141516171819202122### 第一步 ，导包from flask_script import Manager### 第二步 初始化manger对象，传入app应用进行绑定manage = Manager(app)### 第三步，就可以使用manage启动运行项目if __name__ == '__main__': manage.run()### 使用终端运行, (main.py 为项目文件)&gt;&gt; python main.py runserver ### 通过 -？ 来获取执行函数的参数&gt;&gt; python main.py runserver -? # 端口和域名不写，默认为127.0.0.1:5000python manage.py runserver# 通过-h设置启动域名，-p设置启动端口python manage.py runserver -h127.0.0.1 -p8080 Flask-Script 可以直接为当前脚本添加新的命令1234567891011#第一步，首先引入Command基类from flask_script import Manager,Command# 第二步 , 自定义命令类，继承Command基类，并将要执行的逻辑放到run方法里面class Hello(Command): \"\"\"run方法里面存放着要执行的逻辑\"\"\" def run(self): print('123')# 第三步，注册自定义命令类并加上别名manage.add_command('hello', Hello() ) 注意，如果有自定义的其他参数传入，需要使用init构造函数导入 Jinja2模板引擎flask中内置的模板语言，设计思想来源与django中的模板引擎,flask 内置的render_template 函数封装了这个模板引擎 要想在flask中使用模板引擎，需要做以下设置 12345678910#首先在创建flask 应用的时候加上 template_folder 参数，指定模板的根目录app = Flask(__name__,template_folder = 'templates')## 默认是在项目的根目录下的## 在视图函数中设置渲染模板设置模板数据from flask import render_template @app.route('/index')def inde(): return render_template('index.html',title='我的flask 项目') 在视图函数中往janja2 模板传入变量 12345678910111213141516### 视图函数@app.route('/index')def inde(): sts = '这也是一个变量' return render_template('index.html',title='我的flask 项目',sts) ## title就是一个变量, sts 也是 ，这是两种方式，前者是传入已经定义好的变量名，后者是直接变量名加上赋值操作一起做， ### 在模板中使用变量## 使用两个花括号来表示变量名 ，， 这种语法叫做** 变量代码块&#123;&#123;&#125;&#125; &#123;&#123; title &#125;&#125;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&#123;&#123; title &#125;&#125;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; Jinja2 模板中的变量代码块可以是任何python类型后者对象，只要它能够被python的\\str__魔术方法 或者str() 方法转换成字符串就可以，通俗来说只要能被json的对象都可以。 在模板中怎样注释变量 1&#123;# &#123;&#123; name &#125;&#125; #&#125; jinja2模板内置的变量和函数 就是说你可以在模板中直接访问flask内置的函数和对象 Config 你可以直接在模板中访问flask中的config对象 1&lt;h5&gt;&#123;&#123;config.DEBUG&#125;&#125;&lt;/h5&gt; request 注意： 是当前请求的request对象 12&lt;h5&gt;&#123;&#123;request.url&#125;&#125;&lt;/h5&gt;http://127.0.0.1:5000/index session flask中的session对象 12&#123;&#123; session.new&#125;&#125;False g 变量 在视图函数中设置的g变量的name属性的值，然后在模板中可以取出 由于g变量的特性，所以它也只能取到本次请求所携带的g变量的值 1&#123;&#123; g.name &#125;&#125; url_for() url_for 会根据传入的路由器函数名，返回改路由对应的URL，在模板中始终使用url_for() 就可以安全的修改路由绑定的URL，则不必担心模板中渲染出错的链接： 12345678## 显示 flask中方法函数对应的路由url地址&#123;&#123;url_for('home')&#125;&#125;&gt;&gt; /## 当有路由函数需要传入参数时，这是我们也需要传入参数就可以将完整url拼接出来&#123;&#123; url_for('user', userid=1)&#125;&#125;&gt;&gt; /user/1 流程控制 主要包含两个，（与django中的基本保持一致） 12 - if /else /endif- for /endfor 过滤器 常用的过滤器 过滤器名 说明 safe 渲染时不转义 capitalize 把值的首字母转换成大写，其他字母转换成小写 lower 把值转换成小写形式 upper 把值转换成大写形式 title 把值中每个单词的首字母都转换成大写 trim 把值的首尾空格都去掉 striptags 渲染前把值中的所有的HTML标签都删掉 123## safe 过滤器 ,因为默认的安全机制会对html代码字符串进行转码。不让其正常进行渲染。&#123;&#123; index | safe &#125;&#125; 在jinja2 中， 过滤器是可以直接链式调用的1&#123;&#123;\"hello world \" | reverse | uppper &#125;&#125; 链式调用安装 github 可以当做静态资源仓库，调用的url为12345678910https://raw.githubusercontent.com/chenluzhong150394/img/master/1.png### 这是仓库的url，（可以查看内容的）https://raw.githubusercontent.com/chenluzhong150394 https://raw.githubusercontent.com/chenluzhong150394/img/master/11.png lsof -i:8080 linux 查看端口","categories":[{"name":"Python","slug":"Python","permalink":"https://zo.subo.xyz/categories/Python/"}],"tags":[{"name":"flask框架","slug":"flask框架","permalink":"https://zo.subo.xyz/tags/flask框架/"}]},{"title":"Git的安装及常用操作","slug":"git","date":"2019-08-10T05:52:50.000Z","updated":"2019-08-10T17:17:50.681Z","comments":true,"path":"2019/08/10/git/","link":"","permalink":"https://zo.subo.xyz/2019/08/10/git/","excerpt":"","text":"安装gitLinux下安装yum安装 1yum -y install git test windows下安装官网地址： https://git-scm.com/download 下载到本地磁盘 安装 一路【next】就可以了 注意：openssl 一定选它 安装完成后，右击菜单栏，有如下菜单，表示安装完成 进入git bash选项 Git工作区、暂存区和版本库 git的使用本地使用git管理代码git项目仓库的本地搭建12345cd进入到自己希望存储代码的目录路径，并创建本地仓库.git新创建的本地仓库.git是个空仓库 cd 目录路径 git init gitdemo # 如果没有声明目录,则自动把当前目录作为git仓库 checkout 切换分支 pull 拉取远程git代码 branch -a 查看所有分支 管理远程git仓库删除远端git项目中的指定文件和目录 首先拉取远程git仓库 123456##如果本地仓库存在，则只需要pull 将远端git仓库与本地git仓库一直git pull##如果本地仓库不存在，则需要克隆clonegit clone https://gitee.com/chenluzhong/blog.git 使用git删除本地文件或目录 123456## 删除本地文件git rm &lt;file_name&gt;## 删除本地目录### -r 参数是递归删除的意思，如果目录是空的，就不用加这个参数也可以 git rm -r &lt;dir_name&gt; 提交代码到本地仓库 1git commit -m '删除某文件后的版本' 将本地仓库推送到远端 1git push &lt;base_url&gt; -u 本地仓库推送到码云首先码云仓库的地址是: https://gitee.com/chenluzhong/lufeiapi.git 设置全局配置(用户名和邮箱) 12git config --global user.name &apos;chenluzhong&apos;git config --global user.email &apos;18438128833@163.com&apos; 创建git仓库 1git init 提交本地的文件到暂存区 1git add . 将暂存区的内容提交到本地仓库中 1git commit -m &apos;这是第一个版本&apos; 然后关联远程仓库地址 1git remote add origin https://gitee.com/chenluzhong/lufeiapi.git 将本地的主分支与远程的分支进行关联 12git branch --set-upstream-to=origin/master mastergit pull orgin master 将本地仓库推送到远端仓库 1234## -u 参数指定唯一主机, master代表将推送到目标仓库的master主分支$ git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;git push -u origin master:master branch分支操作查看所有分支 查看本地分支 1git branch 查看远程分支 1git branch -a 创建分支 1git branch dev ##新建一个dev的本地分支 切换分支 1git checkout dev ## 切换到dev这个分支 删除分支 删除本地分支 1git branch -d dev ## 删除本地分支 删除远程分支 1git push origin --delete dev ## 删除远程仓库中dev分支","categories":[{"name":"Git","slug":"Git","permalink":"https://zo.subo.xyz/categories/Git/"}],"tags":[{"name":"git操作","slug":"git操作","permalink":"https://zo.subo.xyz/tags/git操作/"}]},{"title":"celery中停止执行task","slug":"celery中停止执行task","date":"2019-07-06T09:26:24.000Z","updated":"2019-08-14T09:56:35.404Z","comments":true,"path":"2019/07/06/celery中停止执行task/","link":"","permalink":"https://zo.subo.xyz/2019/07/06/celery中停止执行task/","excerpt":"","text":"原因因为最近项目需求中需要提供对异步执行任务终止的功能，所以在寻找停止celery task任务的方法。这种需求以前没有碰到过，所以，只能求助于百度和google，但是找遍了资料，都没找到相关的能停止celery task任务的方法(网上找到的一个方法实测不能用，可能是celery版本的原因，我的项目目前使用的是celery 4.0.2) 解决过程由于网上找不到解决办法，于是只能自己想办法了。想到celery 管理工具flower里面好像有停止celery task的功能，于是去找flower的源码，找到接口的源码如下: 1234logger.info(\"Revoking task '%s'\", taskid)terminate = self.get_argument('terminate', default=False, type=bool)self.capp.control.revoke(taskid, terminate=terminate)self.write(dict(message=\"Revoked '%s'\" % taskid)) 核心代码是self.capp.control.revoke 想到去celery里面找寻revoke函数，发现有两处比较可疑，第一个是celery.worker.control.revoke，第二个是celery.app.control.Control.revoke，直觉来看，应该是第二个方法，但是第二个方法是在一个类里面的，要调用这个方法首先需要获取到celery app的实例，后来去celery 配置里面找，发现在init.py文件里面有__all__ = [&#39;celery_app&#39;]这么一句，于是找到突破点了，引用这个包就能获取到celery_app了。 12from test.ceyery_proj import celery_appcelery_app.control.revoke(task_id, terminate=True) 通过这个方法就能终止正在执行的task，至于task_id在执行任务的时候返回了，我将这个id存储在数据库中，这样就可以被拿来控制task的执行了。 写这篇文档的目的主要是帮助小伙伴们不要再踩这个坑了，也为celery提供一点文档补充吧。","categories":[{"name":"Python","slug":"Python","permalink":"https://zo.subo.xyz/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://zo.subo.xyz/tags/Python/"}]},{"title":"GO语言list剖析","slug":"GO语言list剖析","date":"2017-08-23T02:33:42.000Z","updated":"2019-08-10T03:21:14.317Z","comments":true,"path":"2017/08/23/GO语言list剖析/","link":"","permalink":"https://zo.subo.xyz/2017/08/23/GO语言list剖析/","excerpt":"","text":"使用方法在GO语言的标准库中，提供了一个container包，这个包中提供了三种数据类型，就是heap,list和ring，本节要讲的是list的使用以及源码剖析。要使用GO提供的list链表，则首先需要导入list包，如下所示： 1234package mainimport( \"container/list\") 导入包之后，需要了解list中定义了两种数据类型，Element和List，定义如下： 1234567891011121314151617181920// Element is an element of a linked list.type Element struct &#123; // Next and previous pointers in the doubly-linked list of elements. // To simplify the implementation, internally a list l is implemented // as a ring, such that &amp;l.root is both the next element of the last // list element (l.Back()) and the previous element of the first list // element (l.Front()). next, prev *Element // The list to which this element belongs. list *List // The value stored with this element. Value interface&#123;&#125;&#125;type List struct &#123; root Element // sentinel list element, only &amp;root, root.prev, and root.next are used len int // current list length excluding (this) sentinel element&#125; Element里面定义了两个Element类型的指针next, prev以及List类型的指针list, Value用来存储值，List里面定义了一个Element作为链表的Root，len作为链表的长度。 import之后，就可以使用链表了： 12345678910func main() &#123; list_test:=list.New() // 创建list对象 list_test.PushBack(\"123\") // 往List队列尾部插入数据 list_test.PushBack(\"456\") list_test.PushBack(\"789\") fmt.Println(list_test.Len()) // 输出list长度 fmt.Println(list_test.Front()) // 输出list第一个元素 fmt.Println(list_test.Front().Next()) // 输出list第一个元素的下一个元素 fmt.Println(list_test.Front().Next().Next()) // 输出list第三个元素&#125; list提供的方法list提供的方法如下： 1234567891011121314151617181920type Element func (e *Element) Next() *Element func (e *Element) Prev() *Elementtype List func New() *List func (l *List) Back() *Element // 返回最后一个元素 func (l *List) Front() *Element // 返回第一个元素 func (l *List) Init() *List // 链表初始化 func (l *List) InsertAfter(v interface&#123;&#125;, mark *Element) *Element // 在某个元素前插入 func (l *List) InsertBefore(v interface&#123;&#125;, mark *Element) *Element // 在某个元素后插入 func (l *List) Len() int // 返回链表长度 func (l *List) MoveAfter(e, mark *Element) // 把e元素移动到mark之后 func (l *List) MoveBefore(e, mark *Element) // 把e元素移动到mark之前 func (l *List) MoveToBack(e *Element) // 把e元素移动到队列最后 func (l *List) MoveToFront(e *Element) // 把e元素移动到队列最头部 func (l *List) PushBack(v interface&#123;&#125;) *Element // 在队列最后插入元素 func (l *List) PushBackList(other *List) // 在队列最后插入接上新队列 func (l *List) PushFront(v interface&#123;&#125;) *Element // 在队列头部插入元素 func (l *List) PushFrontList(other *List) // 在队列头部插入接上新队列 func (l *List) Remove(e *Element) interface&#123;&#125; // 删除某个元素 源码剖析首先，使用list.New()方法，返回的是一个List对象的指针，源码New() *List &#123; return new(List).Init() &#125;```并执行了List对象的Init()方法对list进行初始化，初始化root的prev和next指针以及list的长度。1234567之后调用list_test.PushBack(&quot;123&quot;)在队列尾部插入元素123，源码如下：```gofunc (l *List) PushBack(v interface&#123;&#125;) *Element &#123; l.lazyInit() return l.insertValue(v, l.root.prev)&#125; 调用lazyInit(),如果链表没有初始化，则先初始化一遍，之后，调用list的insertValue方法，insertValue方法初始化节点之后，调用insert方法进行插入链表。 123func (l *List) insertValue(v interface&#123;&#125;, at *Element) *Element &#123; return l.insert(&amp;Element&#123;Value: v&#125;, at)&#125; 整篇文章最精髓的地方就在insert方法中了，源码如下： 12345678910func (l *List) insert(e, at *Element) *Element &#123; n := at.next // 用中间变量n保存at节点的next指针 at.next = e // at节点的next指向要插入的节点 e.prev = at // 要插入的节点e的prev指向at节点 e.next = n // e的next节点指向中间变量n保存的指针 n.prev = e // at节点的下一个节点的prev指向e节点 e.list = l // e节点的list指向链表的root节点 l.len++ // 链表的长度加一 return e // 返回刚插入节点的指针&#125; 这里的链表结构是双向链表，并且在root节点的prev指针指向了链表的结尾，链表结尾的next指针也指向了root节点，这样，其实形成了一个环形结构，如果是向链表的尾部插入新数据，则将root.prev传递给insert方法的at参数，如果是向头部插入，则将root传递给insert方法的at参数。 这样做的好处是显而易见的，那就是从链表的尾部插入数据，将不需要遍历一遍链表，而只需要将root节点的prev传递给insert方法中就可以了，大大节省了从尾部插入节点的时间。这段代码我看了很久，觉得这个包中最精髓的地方也就在这了，这也是这篇文章诞生的原因。 源码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216// Copyright 2009 The Go Authors. All rights reserved.// Use of this source code is governed by a BSD-style// license that can be found in the LICENSE file.// Package list implements a doubly linked list.//// To iterate over a list (where l is a *List):// for e := l.Front(); e != nil; e = e.Next() &#123;// // do something with e.Value// &#125;//package list// Element is an element of a linked list.type Element struct &#123; // Next and previous pointers in the doubly-linked list of elements. // To simplify the implementation, internally a list l is implemented // as a ring, such that &amp;l.root is both the next element of the last // list element (l.Back()) and the previous element of the first list // element (l.Front()). next, prev *Element // The list to which this element belongs. list *List // The value stored with this element. Value interface&#123;&#125;&#125;// Next returns the next list element or nil.func (e *Element) Next() *Element &#123; if p := e.next; e.list != nil &amp;&amp; p != &amp;e.list.root &#123; return p &#125; return nil&#125;// Prev returns the previous list element or nil.func (e *Element) Prev() *Element &#123; if p := e.prev; e.list != nil &amp;&amp; p != &amp;e.list.root &#123; return p &#125; return nil&#125;// List represents a doubly linked list.// The zero value for List is an empty list ready to use.type List struct &#123; root Element // sentinel list element, only &amp;root, root.prev, and root.next are used len int // current list length excluding (this) sentinel element&#125;// Init initializes or clears list l.func (l *List) Init() *List &#123; l.root.next = &amp;l.root l.root.prev = &amp;l.root l.len = 0 return l&#125;// New returns an initialized list.func New() *List &#123; return new(List).Init() &#125;// Len returns the number of elements of list l.// The complexity is O(1).func (l *List) Len() int &#123; return l.len &#125;// Front returns the first element of list l or nil.func (l *List) Front() *Element &#123; if l.len == 0 &#123; return nil &#125; return l.root.next&#125;// Back returns the last element of list l or nil.func (l *List) Back() *Element &#123; if l.len == 0 &#123; return nil &#125; return l.root.prev&#125;// lazyInit lazily initializes a zero List value.func (l *List) lazyInit() &#123; if l.root.next == nil &#123; l.Init() &#125;&#125;// insert inserts e after at, increments l.len, and returns e.func (l *List) insert(e, at *Element) *Element &#123; n := at.next at.next = e e.prev = at e.next = n n.prev = e e.list = l l.len++ return e&#125;// insertValue is a convenience wrapper for insert(&amp;Element&#123;Value: v&#125;, at).func (l *List) insertValue(v interface&#123;&#125;, at *Element) *Element &#123; return l.insert(&amp;Element&#123;Value: v&#125;, at)&#125;// remove removes e from its list, decrements l.len, and returns e.func (l *List) remove(e *Element) *Element &#123; e.prev.next = e.next e.next.prev = e.prev e.next = nil // avoid memory leaks e.prev = nil // avoid memory leaks e.list = nil l.len-- return e&#125;// Remove removes e from l if e is an element of list l.// It returns the element value e.Value.func (l *List) Remove(e *Element) interface&#123;&#125; &#123; if e.list == l &#123; // if e.list == l, l must have been initialized when e was inserted // in l or l == nil (e is a zero Element) and l.remove will crash l.remove(e) &#125; return e.Value&#125;// PushFront inserts a new element e with value v at the front of list l and returns e.func (l *List) PushFront(v interface&#123;&#125;) *Element &#123; l.lazyInit() return l.insertValue(v, &amp;l.root)&#125;// PushBack inserts a new element e with value v at the back of list l and returns e.func (l *List) PushBack(v interface&#123;&#125;) *Element &#123; l.lazyInit() return l.insertValue(v, l.root.prev)&#125;// InsertBefore inserts a new element e with value v immediately before mark and returns e.// If mark is not an element of l, the list is not modified.func (l *List) InsertBefore(v interface&#123;&#125;, mark *Element) *Element &#123; if mark.list != l &#123; return nil &#125; // see comment in List.Remove about initialization of l return l.insertValue(v, mark.prev)&#125;// InsertAfter inserts a new element e with value v immediately after mark and returns e.// If mark is not an element of l, the list is not modified.func (l *List) InsertAfter(v interface&#123;&#125;, mark *Element) *Element &#123; if mark.list != l &#123; return nil &#125; // see comment in List.Remove about initialization of l return l.insertValue(v, mark)&#125;// MoveToFront moves element e to the front of list l.// If e is not an element of l, the list is not modified.func (l *List) MoveToFront(e *Element) &#123; if e.list != l || l.root.next == e &#123; return &#125; // see comment in List.Remove about initialization of l l.insert(l.remove(e), &amp;l.root)&#125;// MoveToBack moves element e to the back of list l.// If e is not an element of l, the list is not modified.func (l *List) MoveToBack(e *Element) &#123; if e.list != l || l.root.prev == e &#123; return &#125; // see comment in List.Remove about initialization of l l.insert(l.remove(e), l.root.prev)&#125;// MoveBefore moves element e to its new position before mark.// If e or mark is not an element of l, or e == mark, the list is not modified.func (l *List) MoveBefore(e, mark *Element) &#123; if e.list != l || e == mark || mark.list != l &#123; return &#125; l.insert(l.remove(e), mark.prev)&#125;// MoveAfter moves element e to its new position after mark.// If e or mark is not an element of l, or e == mark, the list is not modified.func (l *List) MoveAfter(e, mark *Element) &#123; if e.list != l || e == mark || mark.list != l &#123; return &#125; l.insert(l.remove(e), mark)&#125;// PushBackList inserts a copy of an other list at the back of list l.// The lists l and other may be the same.func (l *List) PushBackList(other *List) &#123; l.lazyInit() for i, e := other.Len(), other.Front(); i &gt; 0; i, e = i-1, e.Next() &#123; l.insertValue(e.Value, l.root.prev) &#125;&#125;// PushFrontList inserts a copy of an other list at the front of list l.// The lists l and other may be the same.func (l *List) PushFrontList(other *List) &#123; l.lazyInit() for i, e := other.Len(), other.Back(); i &gt; 0; i, e = i-1, e.Prev() &#123; l.insertValue(e.Value, &amp;l.root) &#125;&#125;","categories":[{"name":"golang","slug":"golang","permalink":"https://zo.subo.xyz/categories/golang/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://zo.subo.xyz/tags/golang/"},{"name":"list","slug":"list","permalink":"https://zo.subo.xyz/tags/list/"}]},{"title":"GO语言heap剖析","slug":"GO语言heap剖析","date":"2017-08-23T02:33:42.000Z","updated":"2019-08-10T03:21:14.313Z","comments":true,"path":"2017/08/23/GO语言heap剖析/","link":"","permalink":"https://zo.subo.xyz/2017/08/23/GO语言heap剖析/","excerpt":"","text":"heap使用在go语言的标准库container中，实现了三中数据类型：heap,list,ring，list在前面一篇文章中已经写了，现在要写的是heap（堆）的源码剖析。 首先，学会怎么使用heap，第一步当然是导入包了，代码如下： 123456package mainimport ( \"container/heap\" \"fmt\") 这个堆使用的数据结构是最小二叉树，即根节点比左边子树和右边子树的所有值都小。源码里面只是实现了一个接口，它的定义如下： 12345type Interface interface &#123; sort.Interface Push(x interface&#123;&#125;) // add x as element Len() Pop() interface&#123;&#125; // remove and return element Len() - 1.&#125; 从这个接口可以看出，其继承了sort.Interface接口，那么sort.Interface的定义是什么呢？源码如下： 123456789type Interface interface &#123; // Len is the number of elements in the collection. Len() int // Less reports whether the element with // index i should sort before the element with index j. Less(i, j int) bool // Swap swaps the elements with indexes i and j. Swap(i, j int)&#125; 也就是说，我们要使用go标准库给我们提供的heap，那么必须自己实现这些接口定义的方法，需要实现的方法如下： Len() int Less(i, j int) bool Swap(i, j int) Push(x interface{}) Pop() interface{} 实现了这五个方法的数据类型才能使用go标准库给我们提供的heap，下面简单示例为定义一个IntHeap类型，并实现上面五个方法。 123456789101112131415161718192021type IntHeap []int // 定义一个类型func (h IntHeap) Len() int &#123; return len(h) &#125; // 绑定len方法,返回长度func (h IntHeap) Less(i, j int) bool &#123; // 绑定less方法 return h[i] &lt; h[j] // 如果h[i]&lt;h[j]生成的就是小根堆，如果h[i]&gt;h[j]生成的就是大根堆&#125;func (h IntHeap) Swap(i, j int) &#123; // 绑定swap方法，交换两个元素位置 h[i], h[j] = h[j], h[i]&#125;func (h *IntHeap) Pop() interface&#123;&#125; &#123; // 绑定pop方法，从最后拿出一个元素并返回 old := *h n := len(old) x := old[n-1] *h = old[0 : n-1] return x&#125;func (h *IntHeap) Push(x interface&#123;&#125;) &#123; // 绑定push方法，插入新元素 *h = append(*h, x.(int))&#125; 针对IntHeap实现了这五个方法之后，我们就可以使用heap了，下面是具体使用方法： 1234567891011121314151617func main() &#123; h := &amp;IntHeap&#123;2, 1, 5, 6, 4, 3, 7, 9, 8, 0&#125; // 创建slice heap.Init(h) // 初始化heap fmt.Println(*h) fmt.Println(heap.Pop(h)) // 调用pop heap.Push(h, 6) // 调用push fmt.Println(*h) for len(*h) &gt; 0 &#123; fmt.Printf(\"%d \", heap.Pop(h)) &#125;&#125;输出结果：[0 1 3 6 2 5 7 9 8 4]0[1 2 3 6 4 5 7 9 8 6]1 2 3 4 5 6 6 7 8 9 上面就是heap的使用了。 heap提供的方法heap提供的方法不多，具体如下： 123456h := &amp;IntHeap&#123;3, 8, 6&#125; // 创建IntHeap类型的原始数据func Init(h Interface) // 对heap进行初始化，生成小根堆（或大根堆）func Push(h Interface, x interface&#123;&#125;) // 往堆里面插入内容func Pop(h Interface) interface&#123;&#125; // 从堆顶pop出内容func Remove(h Interface, i int) interface&#123;&#125; // 从指定位置删除数据，并返回删除的数据func Fix(h Interface, i int) // 从i位置数据发生改变后，对堆再平衡，优先级队列使用到了该方法 heap源码剖析heap的内部实现，是使用最小(最大)堆，索引排序从根节点开始，然后左子树，右子树的顺序方式。 内部实现的down和up分别表示对堆中的某个元素向下保证最小(最大)堆和向上保证最小(最大)堆。 当往堆中插入一个元素的时候，这个元素插入到最右子树的最后一个节点中，然后调用up向上保证最小(最大)堆。 当要从堆中推出一个元素的时候，先吧这个元素和右子树最后一个节点交换，然后弹出最后一个节点，然后对root调用down，向下保证最小(最大)堆。 好了，开始分析源码： 首先，在使用堆之前，必须调用它的Init方法，初始化堆，生成小根(大根)堆。Init方法源码如下: 123456789101112// A heap must be initialized before any of the heap operations// can be used. Init is idempotent with respect to the heap invariants// and may be called whenever the heap invariants may have been invalidated.// Its complexity is O(n) where n = h.Len().//func Init(h Interface) &#123; // heapify n := h.Len() // 获取数据的长度 for i := n/2 - 1; i &gt;= 0; i-- &#123; // 从长度的一半开始，一直到第0个数据，每个位置都调用down方法，down方法实现的功能是保证从该位置往下保证形成堆 down(h, i, n) &#125;&#125; 接下来看down的源码： 12345678910111213141516171819func down(h Interface, i0, n int) bool &#123; i := i0 // 中间变量，第一次存储的是需要保证往下需要形成堆的节点位置 for &#123; // 死循环 j1 := 2*i + 1 // i节点的左子孩子 if j1 &gt;= n || j1 &lt; 0 &#123; // j1 &lt; 0 after int overflow // 保证其左子孩子没有越界 break &#125; j := j1 // left child // 中间变量j先赋值为左子孩子，之后j将被赋值为左右子孩子中最小（大）的一个孩子的位置 if j2 := j1 + 1; j2 &lt; n &amp;&amp; !h.Less(j1, j2) &#123; j = j2 // = 2*i + 2 // right child &#125; // 这之后，j被赋值为两个孩子中的最小（大）孩子的位置（最小或最大由Less中定义的决定） if !h.Less(j, i) &#123; break &#125; // 若j大于（小于）i，则终止循环 h.Swap(i, j) // 否则交换i和j位置的值 i = j // 令i=j，继续循环，保证j位置的子数是堆结构 &#125; return i &gt; i0&#125; 这是建立堆的核心代码，其实，down并不能完全保证从某个节点往下每个节点都能保持堆的特性，只能保证某个节点的值如果不满足堆的性质，则将该值与其孩子交换，直到该值放到适合的位置，保证该值及其两个子孩子满足堆的性质。 但是，如果是通过Init循环调用down将能保证初始化后所有的节点都保持堆的特性，这是因为循环开始的i := n/2 - 1的取值位置，将会取到最大的一个拥有孩子节点的节点，并且该节点最多只有两个孩子，并且其孩子节点是叶子节点，从该节点往前每个节点如果都能保证down的特性，则整个列表也就符合了堆的性质了。 同样，有down就有up，up保证的是某个节点如果向上没有保证堆的性质，则将其与父节点进行交换，直到该节点放到某个特定位置保证了堆的性质。代码如下： 12345678910func up(h Interface, j int) &#123; for &#123; // 死循环 i := (j - 1) / 2 // parent // j节点的父节点 if i == j || !h.Less(j, i) &#123; // 如果越界，或者满足堆的条件，则结束循环 break &#125; h.Swap(i, j) // 否则将该节点和父节点交换 j = i // 对父节点继续进行检查直到根节点 &#125;&#125; 以上两个方法就是最核心的方法了，所有暴露出来的方法无非就是对这两个方法进行的封装。我们来看看以下这些方法的源码： 123456789101112131415161718192021222324252627func Push(h Interface, x interface&#123;&#125;) &#123; h.Push(x) // 将新插入进来的节点放到最后 up(h, h.Len()-1) // 确保新插进来的节点网上能保证堆结构&#125;func Pop(h Interface) interface&#123;&#125; &#123; n := h.Len() - 1 // 把最后一个节点和第一个节点进行交换，之后，从根节点开始重新保证堆结构，最后把最后那个节点数据丢出并返回 h.Swap(0, n) down(h, 0, n) return h.Pop()&#125;func Remove(h Interface, i int) interface&#123;&#125; &#123; n := h.Len() - 1 pop只是remove的特殊情况，remove是把i位置的节点和最后一个节点进行交换，之后保证从i节点往下及往上都保证堆结构，最后把最后一个节点的数据丢出并返回 if n != i &#123; h.Swap(i, n) down(h, i, n) up(h, i) &#125; return h.Pop()&#125;func Fix(h Interface, i int) &#123; if !down(h, i, h.Len()) &#123; // i节点的数值发生改变后，需要保证堆的再平衡，先调用down保证该节点下面的堆结构，如果有位置交换，则需要保证该节点往上的堆结构，否则就不需要往上保证堆结构，一个小小的优化 up(h, i) &#125;&#125; 以上就是go里面的heap所有的源码了，我也就不贴出完整版源码了，以上理解全部基于个人的理解，如有不当之处，还望批评指正。 利用heap实现优先级队列既然用到了heap，那就用heap实现一个优先级队列吧，这个功能是很好的一个功能。源码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687package mainimport ( \"container/heap\" \"fmt\")type Item struct &#123; value string // 优先级队列中的数据，可以是任意类型，这里使用string priority int // 优先级队列中节点的优先级 index int // index是该节点在堆中的位置&#125;// 优先级队列需要实现heap的interfacetype PriorityQueue []*Item// 绑定Len方法func (pq PriorityQueue) Len() int &#123; return len(pq)&#125;// 绑定Less方法，这里用的是小于号，生成的是小根堆func (pq PriorityQueue) Less(i, j int) bool &#123; return pq[i].priority &lt; pq[j].priority&#125;// 绑定swap方法func (pq PriorityQueue) Swap(i, j int) &#123; pq[i], pq[j] = pq[j], pq[i] pq[i].index, pq[j].index = i, j&#125;// 绑定put方法，将index置为-1是为了标识该数据已经出了优先级队列了func (pq *PriorityQueue) Pop() interface&#123;&#125; &#123; old := *pq n := len(old) item := old[n-1] *pq = old[0 : n-1] item.index = -1 return item&#125;// 绑定push方法func (pq *PriorityQueue) Push(x interface&#123;&#125;) &#123; n := len(*pq) item := x.(*Item) item.index = n *pq = append(*pq, item)&#125;// 更新修改了优先级和值的item在优先级队列中的位置func (pq *PriorityQueue) update(item *Item, value string, priority int) &#123; item.value = value item.priority = priority heap.Fix(pq, item.index)&#125;func main() &#123; // 创建节点并设计他们的优先级 items := map[string]int&#123;\"二毛\": 5, \"张三\": 3, \"狗蛋\": 9&#125; i := 0 pq := make(PriorityQueue, len(items)) // 创建优先级队列，并初始化 for k, v := range items &#123; // 将节点放到优先级队列中 pq[i] = &amp;Item&#123; value: k, priority: v, index: i&#125; i++ &#125; heap.Init(&amp;pq) // 初始化堆 item := &amp;Item&#123; // 创建一个item value: \"李四\", priority: 1, &#125; heap.Push(&amp;pq, item) // 入优先级队列 pq.update(item, item.value, 6) // 更新item的优先级 for len(pq) &gt; 0 &#123; item := heap.Pop(&amp;pq).(*Item) fmt.Printf(\"%.2d:%s index:%.2d\\n\", item.priority, item.value, item.index) &#125;&#125;输出结果：03:张三 index:-0105:二毛 index:-0106:李四 index:-0109:狗蛋 index:-01","categories":[{"name":"golang","slug":"golang","permalink":"https://zo.subo.xyz/categories/golang/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://zo.subo.xyz/tags/golang/"},{"name":"heap","slug":"heap","permalink":"https://zo.subo.xyz/tags/heap/"}]}]}